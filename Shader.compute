// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#define PI 3.14159265
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Agent
{
    float2 position;
    float angle;
};



RWStructuredBuffer<Agent> agents;
RWTexture2D<float4> Result;
int width;
int height;
float deltaTime;
float speed;

// Sense
Texture2D<float4> Source;
float sensorAngleSpacing = 0.5; 
float sensorDistance = 0.02; 
float rotationSpeed = 1;

float Sense(float2 coord, float angleOffset, float agentAngle)
{
    float angle = agentAngle + angleOffset;
    float2 offset = float2(cos(angle), sin(angle)) * sensorDistance;
    float2 samplePos = coord + offset;
    
    int2 texPos = int2(samplePos.x * width, samplePos.y * height);
    texPos = clamp(texPos, int2(0, 0), int2(width - 1, height - 1));

    return Source.Load(int3(texPos, 0)).r;
}

[numthreads(256, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= agents.Length)
        return;

    Agent agent = agents[index];
    
    float2 dir = float2(cos(agent.angle), sin(agent.angle));
    
    float center = Sense(agent.position, 0, agent.angle);
    float left = Sense(agent.position, -sensorAngleSpacing, agent.angle);
    float right = Sense(agent.position, sensorAngleSpacing, agent.angle);
    
    if (center > left && center > right)
    {
    // move foreward
    }
    else if (left > right)
    {
        agent.angle -= rotationSpeed * deltaTime;
    }
    else if (left < right)
    {
        agent.angle += rotationSpeed * deltaTime;
    }
    
    // move foreward
    agent.position += dir * deltaTime * speed;

    // Bounce on edges
    if (agent.position.x < 0.0f || agent.position.x > 1.0f)
    {
        agent.angle = PI - agent.angle;
        agent.position.x = clamp(agent.position.x, 0.0f, 1.0f);
    }

    if (agent.position.y < 0.0f || agent.position.y > 1.0f)
    {
        agent.angle = -agent.angle;
        agent.position.y = clamp(agent.position.y, 0.0f, 1.0f);
    }

    agents[index] = agent;

    // Convert normalized pos to pixel coords
    int2 texPos = int2(agent.position.x * width, agent.position.y * height);
    texPos = clamp(texPos, int2(0, 0), int2(width - 1, height - 1));

    // Set pixel
    Result[texPos] = float4(1, 1, 1, 1);
}
