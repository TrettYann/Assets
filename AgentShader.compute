// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSAgent
#define PI 3.14159265
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Agent
{
    float2 position;
    float angle;
    float energy;
    int blockedSteps;
    int shrinkParticle;
    int devideParticle;
};

// PRNG
float Hash(float2 p)
{
    return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}
int cf(float f){
    return f < 0.5 ? 0 : 1;
}

RWStructuredBuffer<Agent> agents;
RWTexture2D<float4> Result;
Texture2D<float4> Source;
RWTexture2D<float4> OccupancyMap;
uint width;
uint height;
int cursorX;
int cursorY;
float deltaTime;
float speed;
int SensorOffset;
float rotationAngle;
float sensoryAngle;
bool isOscillatory;
bool repellant;
bool drawNutrientPoints;
bool starving;
bool wrap;
int numNutrientPoints;
float deltaAngle;
float starvingSpeed;


[numthreads(256, 1, 1)]
void CSAgent(uint3 id : SV_DispatchThreadID)
{
    
    uint index = id.x;

    if (index >= agents.Length)
        return;

    Agent agent = agents[index];
    agent.devideParticle = 0;

    int2 coord = int2(round(agent.position * float2(width, height)));


    
// Sense logic
    
    float2 front = float2(coord) + SensorOffset * float2(cos(agent.angle), sin(agent.angle));
    float2 frontL = float2(coord) + SensorOffset * float2(cos(agent.angle + sensoryAngle), sin(agent.angle + sensoryAngle));
    float2 frontR = float2(coord) + SensorOffset * float2(cos(agent.angle - sensoryAngle), sin(agent.angle - sensoryAngle));

    // Round
    int2 FrontCoordinate = int2(round(front));
    int2 FrontLeftCoordinate = int2(round(frontL));
    int2 FrontRightCoordinate = int2(round(frontR));

    // Wrap
    if (wrap)
    {
        FrontCoordinate = (FrontCoordinate + uint2(width, height)) % uint2(width, height);
        FrontLeftCoordinate = (FrontLeftCoordinate + uint2(width, height)) % uint2(width, height);
        FrontRightCoordinate = (FrontRightCoordinate + uint2(width, height)) % uint2(width, height);
    }



    
    float FL = Source[FrontLeftCoordinate].r;
    float FR = Source[FrontRightCoordinate].r;
    float F = Source[FrontCoordinate].r;
    
    if (F > FL && F > FR)
    {
        
    }
    else if (F < FL && F < FR)
    {
        if (FR > FL)
        {
            agent.angle -= rotationAngle;
        }
        else
        {
            agent.angle += rotationAngle;
        }

    }
    else if (FR < FL)
    {
        agent.angle += rotationAngle;
    }
    else if (FR > FL)
    {
        agent.angle -= rotationAngle;
    }
    agent.angle = fmod(agent.angle, 2.0 * PI);
    if (agent.angle < 0)
        agent.angle += 2.0 * PI;
    
    float2 dir = float2(cos(agent.angle), sin(agent.angle));
    float surgeFactor = isOscillatory ? (1.0 + agent.blockedSteps) : 1.0;


    float2 next = agent.position + dir * deltaTime * speed * surgeFactor;
    if (wrap)
    {
        next.x = fmod(next.x + 1.0f, 1.0f);
        next.y = fmod(next.y + 1.0f, 1.0f);
    }else
    {
        if (next.x <= 0.0f || next.x >= 0.99999f || next.y <= 0.0f || next.y >= 0.99999f)
        {
            agent.angle = Hash(agent.position.xy * 123.45f) * 2.0f * PI;
        }
        next.x = clamp(next.x, 0.0f, 0.99999f);
        next.y = clamp(next.y, 0.0f, 0.99999f);
    }

    // Convert calculated pos to rounded pixel coords
    int2 nextCoord = int2(round(next * float2(width, height)));
    // Wrap
    if (wrap)
    {
        nextCoord = (nextCoord + uint2(width, height)) % uint2(width, height);

    }

        nextCoord = clamp(nextCoord, uint2(0, 0), uint2(width - 1, height - 1));
    
    
    //float4 occupied = OccupancyMap[nextCoord];
        float occupied = OccupancyMap[nextCoord];
        bool canMove = (occupied < 0.5);
        if (starving)
        {
            if (agent.energy > 0)
            {
                float nextVal = Result[nextCoord];

                if (nextVal > agent.energy)
                {
                    float sum = 0;
                    agent.energy = nextVal - starvingSpeed;

                }
                else
                {
                    agent.energy -= starvingSpeed;
                }
            }
            else
            {
                agent.shrinkParticle = 1;
            }
        }


        if (canMove)
        {
            agent.position = next;
            agent.blockedSteps = 0;
        
        // Occupie Pixel
            OccupancyMap[nextCoord] = float4(1, 1, 1, 1);
        
        // Set pixel
        



            Result[nextCoord] = float4(agent.energy, agent.energy, agent.energy, agent.energy);
        }
        else
        {
            if (isOscillatory)
            {
                agent.blockedSteps = min(agent.blockedSteps + 1, 3);
            }
            else
            {
                float angle = Hash(id.xy) * (2.0 * 3.14159265);
                agent.angle = angle;
                float2 rdir = float2(cos(agent.angle), sin(agent.angle));
                float2 next = agent.position + rdir * deltaTime * speed;

                if (wrap)
                    next = fmod(next + 1.0f, 1.0f);
                else
                    next = clamp(next, 0.001f, 0.999f);

                int2 acoord = int2(floor(next * float2(width, height)));
                acoord = clamp(acoord, int2(0, 0), int2(width - 1, height - 1));
                Result[acoord] = float4(1, 1, 1, 1);
            }
            OccupancyMap[coord] = float4(1, 1, 1, 1);
        }
    
    // Agent window
        int radius = 9; // default
        int sradius = 5;
        float sum = 0;
        float sum2 = 0;
        for (int y = -radius; y <= radius; y++)
        {
            for (int x = -radius; x <= radius; x++)
            {
                float dist = length(float2(x, y));
                int2 pos = coord + int2(x, y);
                if (dist <= radius)
                {
                    pos = (pos + uint2(width, height)) % uint2(width, height);
                    sum += OccupancyMap[pos];

                    if (sradius >= dist)
                    {
                        sum2 += OccupancyMap[pos];
                    }
                }
            }
        }
        if (sum2 > 0 && sum2 < 10)
        {
        //agent.devideParticle = 1;
        }
        if (sum > 24) // default
        {
        //agent.shrinkParticle = 1;
        }
        if (index == 1)
        {
            if (repellant)
            {
                int2 mousePos = int2(cursorX, cursorY);


                int radius = 30;
                for (int y = -radius; y <= radius; y++)
                {
                    for (int x = -radius; x <= radius; x++)
                    {
                        float dist = length(float2(x, y));
                        int2 pos = mousePos + int2(x, y);
                        if (dist <= radius)
                        {
                            float fade = 1 - (dist / radius);
                        //pos = (pos + int2(width, height)) % int2(width, height);
                            Result[pos] = float4(-fade, -fade, -fade, 1);
                        }
                    }
                }
            }
            int cornerRadius = 2;
    
            int2 corners[4] =
            {
                int2(0, 0),
                int2(width - 1, 0),
                int2(0, height - 1),
                int2(width - 1, height - 1)
            };

            for (int i = 0; i < 4; i++)
            {
                int2 c = corners[i];

                for (int y = -cornerRadius; y <= cornerRadius; y++)
                {
                    for (int x = -cornerRadius; x <= cornerRadius; x++)
                    {
                        float dist = length(float2(x, y));
                        if (dist <= cornerRadius)
                        {
                            float fade = 1 - (dist / cornerRadius);
                            fade = clamp(fade, 0.0, 1.0);

                            int2 pos = c + int2(x, y);

                            pos = clamp(pos, int2(0, 0), int2(width - 1, height - 1));

                            Result[pos] = float4(-fade, -fade, -fade, 1);
                        }
                    }
                }
            }
            if (drawNutrientPoints)
            {
                int numPoints = numNutrientPoints;
                int radius = 10;
                float centerDistance = 50;

                uint2 center = uint2(width / 2, height / 2);

                if (numPoints > 0)
                {
                    if (numPoints == 1)
                    {
                        uint2 pos1 = center;

                        for (int y = -radius; y <= radius; y++)
                        {
                            for (int x = -radius; x <= radius; x++)
                            {
                                float dist = length(float2(x, y));
                                int2 pos = pos1 + int2(x, y);

                                if (dist <= radius)
                                {
                                    float fade = 1 - (dist / radius);
                                    fade = max(fade, 0.3);
                                    pos = (pos + uint2(width, height)) % uint2(width, height);
                                    Result[pos] = float4(fade, fade, fade, fade);
                                }
                            }
                        }
                    }
                    else
                    {
                        float angleStep = 2 * 3.14159265 / numPoints;

                        for (int i = 0; i < numPoints; i++)
                        {
                            float angle = i * angleStep;
                            int2 offset = int2(cos(angle) * centerDistance, sin(angle) * centerDistance);
                            uint2 pos1 = center + offset;

                            for (int y = -radius; y <= radius; y++)
                            {
                                for (int x = -radius; x <= radius; x++)
                                {
                                    float dist = length(float2(x, y));
                                    int2 pos = pos1 + int2(x, y);

                                    if (dist <= radius)
                                    {
                                        float fade = 1 - (dist / radius);
                                        fade = max(fade, 0.1);
                                        pos = (pos + uint2(width, height)) % uint2(width, height);
                                        Result[pos] = float4(fade, fade, fade, fade);
                                    }
                                }
                            }
                        }
                    }
                }
            }

        }


        agents[index] = agent;
    
    
    }
