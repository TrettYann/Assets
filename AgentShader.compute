// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSAgent
#define PI 3.14159265
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Agent
{
    float2 position;
    float angle;
    int blockedSteps;
    int shrinkParticle;
};

// PRNG
float Hash(float2 p)
{
    return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}

RWStructuredBuffer<Agent> agents;
RWTexture2D<float4> Result;
Texture2D<float4> Source;
RWTexture2D<float4> OccupancyMap;
uint width;
uint height;
int cursorX;
int cursorY;
float deltaTime;
float speed;
int SensorOffset;
float rotationAngle;
float sensoryAngle;
bool isOscillatory;
bool repellant;
bool drawNutrientPoints;
float deltaAngle;

[numthreads(256, 1, 1)]
void CSAgent(uint3 id : SV_DispatchThreadID)
{
    
    uint index = id.x;

    if (index >= agents.Length)
        return;

    Agent agent = agents[index];

    int2 coord = int2(round(agent.position * float2(width, height)));


    
// Sense logic
    
    float2 front = float2(coord) + SensorOffset * float2(cos(agent.angle), sin(agent.angle));
    float2 frontL = float2(coord) + SensorOffset * float2(cos(agent.angle + sensoryAngle), sin(agent.angle + sensoryAngle));
    float2 frontR = float2(coord) + SensorOffset * float2(cos(agent.angle - sensoryAngle), sin(agent.angle - sensoryAngle));

    // Round
    int2 FrontCoordinate = int2(round(front));
    int2 FrontLeftCoordinate = int2(round(frontL));
    int2 FrontRightCoordinate = int2(round(frontR));

    // Wrap
    FrontCoordinate = (FrontCoordinate + uint2(width, height)) % uint2(width, height);
    FrontLeftCoordinate = (FrontLeftCoordinate + uint2(width, height)) % uint2(width, height);
    FrontRightCoordinate = (FrontRightCoordinate + uint2(width, height)) % uint2(width, height);
    
    float FL = Source[FrontLeftCoordinate].r;
    float FR = Source[FrontRightCoordinate].r;
    float F = Source[FrontCoordinate].r;
    
    if (F > FL && F > FR)
    {
        
    }
    else if (F < FL && F < FR)
    {
        if (FR > FL)
        {
            agent.angle -= rotationAngle;
        }
        else
        {
            agent.angle += rotationAngle;
        }

    }
    else if (FR < FL)
    {
        agent.angle += rotationAngle;
    }
    else if (FR > FL)
    {
        agent.angle -= rotationAngle;
    }
    agent.angle = fmod(agent.angle, 2.0 * PI);
    if (agent.angle < 0)
        agent.angle += 2.0 * PI;
    
    float2 dir = float2(cos(agent.angle), sin(agent.angle));
    float surgeFactor = isOscillatory ? (1.0 + agent.blockedSteps) : 1.0;


    float2 next = agent.position + dir * deltaTime * speed * surgeFactor;
    next.x = fmod(next.x + 1.0f, 1.0f);
    next.y = fmod(next.y + 1.0f, 1.0f);
    // Convert calculated pos to rounded pixel coords
    int2 nextCoord = int2(round(next * float2(width, height)));
    // Wrap
    nextCoord = (nextCoord + uint2(width, height)) % uint2(width, height);
    nextCoord = clamp(nextCoord, uint2(0, 0), uint2(width - 1, height - 1));
    
    //float4 occupied = OccupancyMap[nextCoord];
    float occupied = OccupancyMap[nextCoord].r;
    bool canMove = (occupied < 0.5);
    
    if (canMove)
    {
        agent.position = next;
        agent.blockedSteps = 0;
        
        // Occupie Pixel
        OccupancyMap[nextCoord] = float4(1, 1, 1, 1);
        
        // Set pixel
        Result[nextCoord] = float4(1, 1, 1, 1);
    }
    else
    {
        if (isOscillatory)
        {
            agent.blockedSteps = min(agent.blockedSteps + 1, 3);
        }
        else
        {
            float angle = Hash(id.xy) * (2.0 * 3.14159265);
            agent.angle = angle;
            float2 rdir = float2(cos(agent.angle), sin(agent.angle));
            int2 acoord = int2(round(agent.position + rdir * deltaTime * speed));
            Result[acoord] = float4(1, 1, 1, 1);
        }
        OccupancyMap[coord] = float4(1, 1, 1, 1);
    }
    
    // Agent window
    int radius = 9; // default
    int sradius = 5;
    float sum = 0;
    for (int y = -radius; y <= radius; y++)
    {
        for (int x = -radius; x <= radius; x++)
        {
            float dist = length(float2(x, y));
            int2 pos = coord + int2(x, y);
            if (dist <= radius)
            {
                pos = (pos + uint2(width, height)) % uint2(width, height);
                sum += OccupancyMap[pos].r;


            }
        }
    }
    if (sum > 24) // default
    {
        agent.shrinkParticle = 1;
        OccupancyMap[coord] = float4(0, 0, 0, 0);
    }
    if (index == 1)
    {
        if (repellant)
        {
            int2 mousePos = int2(cursorX, cursorY);


            int radius = 30;
            for (int y = -radius; y <= radius; y++)
            {
                for (int x = -radius; x <= radius; x++)
                {
                    float dist = length(float2(x, y));
                    int2 pos = mousePos + int2(x, y);
                    if (dist <= radius)
                    {
                        float fade = 1 - (dist / radius);
                        //pos = (pos + int2(width, height)) % int2(width, height);
                        Result[pos] = float4(-fade, -fade, -fade, 1);
                    }
                }
            }
        }
        if (drawNutrientPoints)
        {
            uint2 pos1 = uint2(width / 2, height / 2);
            int radius = 50;

            for (int y = -radius; y <= radius; y++)
            {
                for (int x = -radius; x <= radius; x++)
                {
                    float dist = length(float2(x, y));
                    int2 pos = pos1 + int2(x, y);
                    if (dist <= radius)
                    {
                        float fade = 1 - (dist / radius);
                        pos = (pos + uint2(width, height)) % uint2(width, height);
                        Result[pos] = float4(fade, fade, fade, fade);
                    }
                }
            }
        }

    }


     agents[index] = agent;
    
    
}
